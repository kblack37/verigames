package cgs.server;

import haxe.Constraints.Function;
import cgs.server.logging.CGSServerConstants;
import cgs.server.logging.ICGSServerProps;
import cgs.server.logging.ICGSServerProps.ServerType;
import cgs.server.logging.ICGSServerProps.LoggingVersion;
import cgs.server.logging.requests.RequestDependency;
import cgs.server.requests.IUrlRequestHandler;
import cgs.server.requests.UrlRequest;
import cgs.server.responses.ServerTimeResponseStatus;
import cgs.server.utils.INtpTime;

class NtpTimeService extends RemoteService implements INtpTime
{
    public var timeRequestDependency(get, never) : RequestDependency;
    public var isTimeValid(get, never) : Bool;
    public var timeRequested(get, never) : Bool;
    public var clientTimeStamp(get, never) : Float;

    //Callbacks that have been registered to be notified when ntp time is valid.
    private var _timeCallbacks : Array<Function>;
    
    private var _serverTime : Float = -1;
    private var _clientTimeOffset : Float;
    
    //Time at which the server time was requested.
    private var _requestingTime : Bool;
    private var _requestedTime : Float;
    private var _requestDelay : Float;
    
    private var _timeRequestDependency : RequestDependency;
    
    public function new(requestHandler : IUrlRequestHandler, useHttps : Bool)
    {
        super(requestHandler, CGSServerConstants.GetTimeUrl(PRODUCTION_SERVER, useHttps, CURRENT_VERSION));
        
        _timeCallbacks = new Array<Function>();
        requestTime();
    }
    
    private function get_timeRequestDependency() : RequestDependency
    {
        return _timeRequestDependency;
    }
    
    /**
     * Add a callback that will be notified when server time can be used.
     * If callback is added and time is already valid callback will be
     * called immediatly.
     */
    public function addTimeValidCallback(callback : Function) : Void
    {
        if (isTimeValid)
        {
            callback();
            return;
        }
        
        _timeCallbacks.push(callback);
    }
    
    private function get_isTimeValid() : Bool
    {
        return _serverTime >= 0;
    }
    
    private function get_timeRequested() : Bool
    {
        return _requestingTime || isTimeValid;
    }
    
    /**
     * Get a client ts in seconds. Timestamp is UTC. If the request to the server
     * failed just a local timestamp will be returned.
     */
    private function get_clientTimeStamp() : Float
    {
        if (_serverTime > 0)
        {
            return _serverTime + (Math.round(haxe.Timer.stamp() * 1000) - _clientTimeOffset);
        }
        else
        {
            return Math.round(haxe.Timer.stamp() * 1000);
        }
    }
    
    /**
     * Get a client timestamp that is offset by a locally generated timestamp
     *
     * @param localTime timestamp that should have been
     * generated by calling getTimer().
     */
    public function getOffsetClientTimeStamp(localTime : Float) : Float
    {
        return _serverTime + (localTime - _clientTimeOffset);
    }
    
    private function requestTime() : Void
    {
        var request : UrlRequest = new UrlRequest(url, null, 
        function(response : ServerTimeResponseStatus) : Void
        {
            var time : Float = response.time;
            
            _requestingTime = false;
            if (time >= 0)
            {
                var returnTime : Float = Math.round(haxe.Timer.stamp() * 1000);
                _requestDelay = (returnTime - _requestedTime) / 2;
                time += _requestDelay;
                
                _clientTimeOffset = returnTime;
                _serverTime = time;
            }
            
            handleTimeLoaded();
        });
        
        request.responseStatus = new ServerTimeResponseStatus();
        
        //Only allow a couple failures to
        //allow logging to continue without timestamps.
        request.maxFailures = 3;
        
        _requestingTime = true;
        _requestedTime = Math.round(haxe.Timer.stamp() * 1000);
        
        var requestId : Int = sendRequest(request);
        
        _timeRequestDependency = new RequestDependency(requestId, false);
    }
    
    private function handleTimeLoaded() : Void
    {
        for (callback in _timeCallbacks)
        {
            callback();
        }
        
        _timeCallbacks = null;
    }
}
